(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{411:function(e,t,a){"use strict";a.r(t);var s=a(32),o=Object(s.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"sticky-patches"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sticky-patches","aria-hidden":"true"}},[e._v("#")]),e._v(" Sticky Patches")]),e._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[e._v("Note")]),a("p",[e._v("This functionality is not available for ePortal customers. If you are using ePortal, please use "),a("RouterLink",{attrs:{to:"/kernelcare-enterprise/#feed-management"}},[e._v("Feeds")]),e._v(" instead.")],1)]),a("p",[e._v("Sometimes you don't want to use the latest patches, but you'd like to control which patches are get installed instead. For example, you have tested the patch released on 25th of May 2018 and want to use that patch across all servers.")]),e._v(" "),a("p",[e._v("You can do it by setting "),a("code",[e._v("STICKY_PATCH=250518")]),e._v(" (ddmmyy format) in "),a("code",[e._v("/etc/sysconfig/kcare/kcare.conf")]),e._v("\nThis guarantees that when "),a("code",[e._v("kcarectl --update")]),e._v(" or "),a("code",[e._v("kcarectl --auto-update")]),e._v(" is called, you will get patches from that date and not the newest patches.")]),e._v(" "),a("p",[e._v("With "),a("code",[e._v("STICKY_PATCH")]),e._v(" you can go back as far as 60 days.")]),e._v(" "),a("p",[e._v("Alternatively, you can set "),a("code",[e._v("STICKY_PATCH=KEY")]),e._v("\nThis way you can control the date from which patches will be applied using KernelCare keys in CLN.\nOn update, the actual date will be retrieved from CLN (from Key settings) for the key used to register a particular server (not supported for IP based servers).")]),e._v(" "),a("p",[e._v("This is very useful if you want to test patches in QA first and later roll them out to production without doing any changes on the systems.")]),e._v(" "),a("p",[e._v("Here is how you can do that:")]),e._v(" "),a("ul",[a("li",[e._v("Set "),a("code",[e._v("STICKY_PATCH=KEY")]),e._v(" on all your servers.")]),e._v(" "),a("li",[e._v("Register QA servers with one KEY, and Production servers with ANOTHER key.")]),e._v(" "),a("li",[e._v("Then, stop new updates for Production servers. In CLN set "),a("code",[e._v("Sticky Tag")]),e._v(" to "),a("code",[e._v("yesterday")]),e._v(". You can do it by editing KEY in CLN in DDMMYY format.")]),e._v(" "),a("li",[e._v("Now, for example, let's use patches as of 03052018 (DDMMYY format). Set them for your QA server key. On the next auto-update, your QA servers will get those patches (auto-updates are typically every 4 hours).")])]),e._v(" "),a("p",[e._v("Once you are happy with this patches, set the same Sticky Tag for Production servers key. In 4 hours your production servers should be updated to the same patches that QA servers were.")]),e._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[e._v("Note")]),a("p",[e._v("You can choose any date within the last 60 days. You cannot choose today's date or date in the future.")])]),a("h4",{attrs:{id:"how-to-find-a-proper-sticky-patch-name"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-to-find-a-proper-sticky-patch-name","aria-hidden":"true"}},[e._v("#")]),e._v(" How to find a proper sticky patch name")]),e._v(" "),a("p",[e._v('Let\'s assume that you have some kernel patch that you want to "stick" with. All you need is to find a proper label for that patch.')]),e._v(" "),a("p",[a("img",{attrs:{src:"/images/sticky-proper-label.png",alt:"sticky-proper-label"}})]),e._v(" "),a("p",[e._v("As you can see, the patch was released at 2020-09-16. And if apply label's date format, it becomes "),a("code",[e._v("16092020")]),e._v(" that will be the sticky patch value.")])])},[],!1,null,null,null);t.default=o.exports}}]);